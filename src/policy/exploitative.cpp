#include "exploitative.h"

using namespace std;
using namespace torch;
using namespace lietorch;

void FullyExploitativePolicy::updateTarget (const Pose2 &target) {
	_predictor.updateTarget (target.translation ().coeffs);
	_terminator.updateTarget (target.translation ().coeffs);
}

Policy::Result FullyExploitativePolicy::followPolicy (const State &initialState)
{
	Terminator::Type cause;

	Tensor trajectory = predict (initialState, cause);

	if (cause == Terminator::TERMINATION_TARGET_APPROACHED){
		if (trajectory.size(0) > 1) {
			// Return first sample after initial condition
			return {trajectory[1], RESULT_ACCEPT};
		} else // it means the initial state is already close to target
			return {Tensor (), RESULT_COMPLETE}; // then switch policy
	} else
		return {Tensor (), RESULT_FAIL};
}

Tensor FullyExploitativePolicy::debugHistory()  {
	return _predictHistory;
}
