#include "exploitative.h"

using namespace std;
using namespace torch;
using namespace lietorch;

void FullyExploitativePolicy::targetUpdated () {
	if (!_framesTracker->ready (FRAME_MEASURES))
		return;

	Pose2 target = _framesTracker->getTf (FRAME_TARGET, FRAME_MEASURES);
	_predictor.updateTarget (target.translation ().coeffs);
	_terminator.updateTarget (target.translation ().coeffs);
}

Policy::Result FullyExploitativePolicy::followPolicy (const State &initialState)
{
	Terminator::Type cause;

	if (!_framesTracker->ready(FRAME_TARGET))
		return {Tensor (), RESULT_FAIL};

	// Relative target pose might have changed wrt measures frame
	targetUpdated ();

	Tensor trajectory = predict (initialState, cause);

	cout << "Prediction terminated due to \e[34m" << terminationStrings[cause] << "\e[0m" << endl;

	if (cause == Terminator::TERMINATION_TARGET_APPROACHED){
		if (trajectory.size(0) > 1) {
			// Return first sample after initial condition
			return {trajectory[1], RESULT_ACCEPT};
		} else // it means the initial state is already close to target
			return {Tensor (), RESULT_FINALIZE}; // then switch to a docking policy
	} else
		return {Tensor (), RESULT_FAIL};
}

Tensor FullyExploitativePolicy::debugHistory()  {
	return _predictHistory;
}
